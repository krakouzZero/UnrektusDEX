/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export interface ZapInterface extends utils.Interface {
  functions: {
    "recoverWrongTokens(address,uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "updateMaxZapInverseRatio(uint256)": FunctionFragment;
    "zapInDOGE(address,uint256)": FunctionFragment;
    "zapInDOGERebalancing(address,uint256,address,uint256,uint256,bool)": FunctionFragment;
    "zapInToken(address,uint256,address,uint256)": FunctionFragment;
    "zapInTokenRebalancing(address,address,uint256,uint256,address,uint256,uint256,bool)": FunctionFragment;
    "zapOutDOGE(address,uint256,uint256,uint256)": FunctionFragment;
    "zapOutToken(address,address,uint256,uint256,uint256)": FunctionFragment;
    "estimateZapInRebalancingSwap(address,address,uint256,uint256,address)": FunctionFragment;
    "estimateZapInSwap(address,uint256,address)": FunctionFragment;
    "estimateZapOutSwap(address,uint256,address)": FunctionFragment;
    "MAX_INT()": FunctionFragment;
    "maxZapReverseRatio()": FunctionFragment;
    "MINIMUM_AMOUNT()": FunctionFragment;
    "owner()": FunctionFragment;
    "WDOGE()": FunctionFragment;
    "wojakRouter()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "recoverWrongTokens",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMaxZapInverseRatio",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "zapInDOGE",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "zapInDOGERebalancing",
    values: [string, BigNumberish, string, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "zapInToken",
    values: [string, BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "zapInTokenRebalancing",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "zapOutDOGE",
    values: [string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "zapOutToken",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateZapInRebalancingSwap",
    values: [string, string, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateZapInSwap",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateZapOutSwap",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(functionFragment: "MAX_INT", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "maxZapReverseRatio",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MINIMUM_AMOUNT",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "WDOGE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "wojakRouter",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "recoverWrongTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMaxZapInverseRatio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "zapInDOGE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "zapInDOGERebalancing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "zapInToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "zapInTokenRebalancing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "zapOutDOGE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "zapOutToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateZapInRebalancingSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateZapInSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateZapOutSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MAX_INT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxZapReverseRatio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MINIMUM_AMOUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "WDOGE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "wojakRouter",
    data: BytesLike
  ): Result;

  events: {
    "AdminTokenRecovery(address,uint256)": EventFragment;
    "NewMaxZapReverseRatio(uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ZapIn(address,address,uint256,uint256,address)": EventFragment;
    "ZapInRebalancing(address,address,address,uint256,uint256,uint256,address)": EventFragment;
    "ZapOut(address,address,uint256,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminTokenRecovery"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewMaxZapReverseRatio"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ZapIn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ZapInRebalancing"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ZapOut"): EventFragment;
}

export type AdminTokenRecoveryEvent = TypedEvent<
  [string, BigNumber],
  { tokenAddress: string; amountTokens: BigNumber }
>;

export type AdminTokenRecoveryEventFilter =
  TypedEventFilter<AdminTokenRecoveryEvent>;

export type NewMaxZapReverseRatioEvent = TypedEvent<
  [BigNumber],
  { maxZapReverseRatio: BigNumber }
>;

export type NewMaxZapReverseRatioEventFilter =
  TypedEventFilter<NewMaxZapReverseRatioEvent>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  { previousOwner: string; newOwner: string }
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export type ZapInEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string],
  {
    tokenToZap: string;
    lpToken: string;
    tokenAmountIn: BigNumber;
    lpTokenAmountReceived: BigNumber;
    user: string;
  }
>;

export type ZapInEventFilter = TypedEventFilter<ZapInEvent>;

export type ZapInRebalancingEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, string],
  {
    token0ToZap: string;
    token1ToZap: string;
    lpToken: string;
    token0AmountIn: BigNumber;
    token1AmountIn: BigNumber;
    lpTokenAmountReceived: BigNumber;
    user: string;
  }
>;

export type ZapInRebalancingEventFilter =
  TypedEventFilter<ZapInRebalancingEvent>;

export type ZapOutEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string],
  {
    lpToken: string;
    tokenToReceive: string;
    lpTokenAmount: BigNumber;
    tokenAmountReceived: BigNumber;
    user: string;
  }
>;

export type ZapOutEventFilter = TypedEventFilter<ZapOutEvent>;

export interface Zap extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ZapInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    recoverWrongTokens(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    updateMaxZapInverseRatio(
      _maxZapInverseRatio: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    zapInDOGE(
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    zapInDOGERebalancing(
      _token1ToZap: string,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    zapInToken(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    zapInTokenRebalancing(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    zapOutDOGE(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    zapOutToken(
      _lpToken: string,
      _tokenToReceive: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    estimateZapInRebalancingSwap(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        swapAmountIn: BigNumber;
        swapAmountOut: BigNumber;
        sellToken0: boolean;
      }
    >;

    estimateZapInSwap(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string] & {
        swapAmountIn: BigNumber;
        swapAmountOut: BigNumber;
        swapTokenOut: string;
      }
    >;

    estimateZapOutSwap(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenToReceive: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string] & {
        swapAmountIn: BigNumber;
        swapAmountOut: BigNumber;
        swapTokenOut: string;
      }
    >;

    MAX_INT(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxZapReverseRatio(overrides?: CallOverrides): Promise<[BigNumber]>;

    MINIMUM_AMOUNT(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    WDOGE(overrides?: CallOverrides): Promise<[string]>;

    wojakRouter(overrides?: CallOverrides): Promise<[string]>;
  };

  recoverWrongTokens(
    _tokenAddress: string,
    _tokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  updateMaxZapInverseRatio(
    _maxZapInverseRatio: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  zapInDOGE(
    _lpToken: string,
    _tokenAmountOutMin: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  zapInDOGERebalancing(
    _token1ToZap: string,
    _token1AmountIn: BigNumberish,
    _lpToken: string,
    _tokenAmountInMax: BigNumberish,
    _tokenAmountOutMin: BigNumberish,
    _isToken0Sold: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  zapInToken(
    _tokenToZap: string,
    _tokenAmountIn: BigNumberish,
    _lpToken: string,
    _tokenAmountOutMin: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  zapInTokenRebalancing(
    _token0ToZap: string,
    _token1ToZap: string,
    _token0AmountIn: BigNumberish,
    _token1AmountIn: BigNumberish,
    _lpToken: string,
    _tokenAmountInMax: BigNumberish,
    _tokenAmountOutMin: BigNumberish,
    _isToken0Sold: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  zapOutDOGE(
    _lpToken: string,
    _lpTokenAmount: BigNumberish,
    _tokenAmountOutMin: BigNumberish,
    _totalTokenAmountOutMin: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  zapOutToken(
    _lpToken: string,
    _tokenToReceive: string,
    _lpTokenAmount: BigNumberish,
    _tokenAmountOutMin: BigNumberish,
    _totalTokenAmountOutMin: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  estimateZapInRebalancingSwap(
    _token0ToZap: string,
    _token1ToZap: string,
    _token0AmountIn: BigNumberish,
    _token1AmountIn: BigNumberish,
    _lpToken: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      swapAmountIn: BigNumber;
      swapAmountOut: BigNumber;
      sellToken0: boolean;
    }
  >;

  estimateZapInSwap(
    _tokenToZap: string,
    _tokenAmountIn: BigNumberish,
    _lpToken: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string] & {
      swapAmountIn: BigNumber;
      swapAmountOut: BigNumber;
      swapTokenOut: string;
    }
  >;

  estimateZapOutSwap(
    _lpToken: string,
    _lpTokenAmount: BigNumberish,
    _tokenToReceive: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string] & {
      swapAmountIn: BigNumber;
      swapAmountOut: BigNumber;
      swapTokenOut: string;
    }
  >;

  MAX_INT(overrides?: CallOverrides): Promise<BigNumber>;

  maxZapReverseRatio(overrides?: CallOverrides): Promise<BigNumber>;

  MINIMUM_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  WDOGE(overrides?: CallOverrides): Promise<string>;

  wojakRouter(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    recoverWrongTokens(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateMaxZapInverseRatio(
      _maxZapInverseRatio: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    zapInDOGE(
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    zapInDOGERebalancing(
      _token1ToZap: string,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    zapInToken(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    zapInTokenRebalancing(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    zapOutDOGE(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    zapOutToken(
      _lpToken: string,
      _tokenToReceive: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    estimateZapInRebalancingSwap(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        swapAmountIn: BigNumber;
        swapAmountOut: BigNumber;
        sellToken0: boolean;
      }
    >;

    estimateZapInSwap(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string] & {
        swapAmountIn: BigNumber;
        swapAmountOut: BigNumber;
        swapTokenOut: string;
      }
    >;

    estimateZapOutSwap(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenToReceive: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string] & {
        swapAmountIn: BigNumber;
        swapAmountOut: BigNumber;
        swapTokenOut: string;
      }
    >;

    MAX_INT(overrides?: CallOverrides): Promise<BigNumber>;

    maxZapReverseRatio(overrides?: CallOverrides): Promise<BigNumber>;

    MINIMUM_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    WDOGE(overrides?: CallOverrides): Promise<string>;

    wojakRouter(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "AdminTokenRecovery(address,uint256)"(
      tokenAddress?: string | null,
      amountTokens?: null
    ): AdminTokenRecoveryEventFilter;
    AdminTokenRecovery(
      tokenAddress?: string | null,
      amountTokens?: null
    ): AdminTokenRecoveryEventFilter;

    "NewMaxZapReverseRatio(uint256)"(
      maxZapReverseRatio?: null
    ): NewMaxZapReverseRatioEventFilter;
    NewMaxZapReverseRatio(
      maxZapReverseRatio?: null
    ): NewMaxZapReverseRatioEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "ZapIn(address,address,uint256,uint256,address)"(
      tokenToZap?: string | null,
      lpToken?: string | null,
      tokenAmountIn?: null,
      lpTokenAmountReceived?: null,
      user?: string | null
    ): ZapInEventFilter;
    ZapIn(
      tokenToZap?: string | null,
      lpToken?: string | null,
      tokenAmountIn?: null,
      lpTokenAmountReceived?: null,
      user?: string | null
    ): ZapInEventFilter;

    "ZapInRebalancing(address,address,address,uint256,uint256,uint256,address)"(
      token0ToZap?: string | null,
      token1ToZap?: string | null,
      lpToken?: null,
      token0AmountIn?: null,
      token1AmountIn?: null,
      lpTokenAmountReceived?: null,
      user?: string | null
    ): ZapInRebalancingEventFilter;
    ZapInRebalancing(
      token0ToZap?: string | null,
      token1ToZap?: string | null,
      lpToken?: null,
      token0AmountIn?: null,
      token1AmountIn?: null,
      lpTokenAmountReceived?: null,
      user?: string | null
    ): ZapInRebalancingEventFilter;

    "ZapOut(address,address,uint256,uint256,address)"(
      lpToken?: string | null,
      tokenToReceive?: string | null,
      lpTokenAmount?: null,
      tokenAmountReceived?: null,
      user?: string | null
    ): ZapOutEventFilter;
    ZapOut(
      lpToken?: string | null,
      tokenToReceive?: string | null,
      lpTokenAmount?: null,
      tokenAmountReceived?: null,
      user?: string | null
    ): ZapOutEventFilter;
  };

  estimateGas: {
    recoverWrongTokens(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    updateMaxZapInverseRatio(
      _maxZapInverseRatio: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    zapInDOGE(
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    zapInDOGERebalancing(
      _token1ToZap: string,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    zapInToken(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    zapInTokenRebalancing(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    zapOutDOGE(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    zapOutToken(
      _lpToken: string,
      _tokenToReceive: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    estimateZapInRebalancingSwap(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateZapInSwap(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateZapOutSwap(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenToReceive: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    MAX_INT(overrides?: CallOverrides): Promise<BigNumber>;

    maxZapReverseRatio(overrides?: CallOverrides): Promise<BigNumber>;

    MINIMUM_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    WDOGE(overrides?: CallOverrides): Promise<BigNumber>;

    wojakRouter(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    recoverWrongTokens(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    updateMaxZapInverseRatio(
      _maxZapInverseRatio: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    zapInDOGE(
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    zapInDOGERebalancing(
      _token1ToZap: string,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    zapInToken(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    zapInTokenRebalancing(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      _tokenAmountInMax: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _isToken0Sold: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    zapOutDOGE(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    zapOutToken(
      _lpToken: string,
      _tokenToReceive: string,
      _lpTokenAmount: BigNumberish,
      _tokenAmountOutMin: BigNumberish,
      _totalTokenAmountOutMin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    estimateZapInRebalancingSwap(
      _token0ToZap: string,
      _token1ToZap: string,
      _token0AmountIn: BigNumberish,
      _token1AmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    estimateZapInSwap(
      _tokenToZap: string,
      _tokenAmountIn: BigNumberish,
      _lpToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    estimateZapOutSwap(
      _lpToken: string,
      _lpTokenAmount: BigNumberish,
      _tokenToReceive: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_INT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxZapReverseRatio(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MINIMUM_AMOUNT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WDOGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wojakRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
